import os
import logging
import mimetypes
import time 
import asyncio # ğŸ’¡ Ø¥Ø¶Ø§ÙØ© Ù…ÙƒØªØ¨Ø© asyncio Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªØ²Ø§Ù…Ù†
import threading # ğŸ’¡ Ø¥Ø¶Ø§ÙØ© Ù…ÙƒØªØ¨Ø© threading Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù€ Webhook ÙÙŠ Ø®Ù„ÙÙŠØ© Flask

from sqlalchemy import create_engine, text
from sqlalchemy.exc import OperationalError, SQLAlchemyError
from telegram import Update, error
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, ConversationHandler
from google import genai 
# ğŸ› ï¸ Ø§Ù„Ø¥Ø¶Ø§ÙØ§Øª Ù„Ø¯Ù…Ø¬ Ø®Ø§Ø¯Ù… Ø§Ù„ÙˆÙŠØ¨ (Flask)
from flask import Flask, send_from_directory, request 
import requests 

# ----------------------------------------
# 1. Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆØ§Ù„Ø«ÙˆØ§Ø¨Øª
# ----------------------------------------
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
MAX_TELEGRAM_MESSAGE_LENGTH = 4096 
MAX_WAIT_TIME = 300 
# ğŸ”‘ ÙŠØ¬Ø¨ ØªØºÙŠÙŠØ± Ù‡Ø°Ø§ Ø§Ù„Ø±Ù‚Ù… Ø¥Ù„Ù‰ Ù…Ø¹Ø±Ù Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø¯ÙŠØ± Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
ADMIN_ID = 1050772765 

# ----------------------------------------
# 2. Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª (PostgreSQL)
# ----------------------------------------

DATABASE_URL = os.getenv("DATABASE_URL")
engine = None

if DATABASE_URL:
    try:
        engine = create_engine(DATABASE_URL)
        logging.info("PostgreSQL engine initialized successfully.")
    except Exception as e:
        logging.error(f"Failed to create PostgreSQL engine: {e}")
else:
    logging.warning("DATABASE_URL not set. Database functions will not work.")

def init_db():
    """ØªÙ‡ÙŠØ¦Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† ÙˆØ§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙÙŠ Postgres."""
    if not engine:
        logging.error("Database engine is not available.")
        return

    try:
        with engine.connect() as connection:
            # 1. Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (users)
            connection.execute(text(f"""
                CREATE TABLE IF NOT EXISTS users (
                    user_id BIGINT PRIMARY KEY,
                    first_name TEXT,
                    username TEXT,
                    is_active INTEGER DEFAULT 1,
                    join_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
            """))
            
            # 2. Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ (messages)
            connection.execute(text(f"""
                CREATE TABLE IF NOT EXISTS messages (
                    id SERIAL PRIMARY KEY,
                    user_id BIGINT REFERENCES users(user_id) ON DELETE CASCADE,
                    message_content TEXT,
                    message_type TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                );
            """))
            connection.commit()
            logging.info("Users and Messages tables created or confirmed in PostgreSQL.")
    except OperationalError as e:
        logging.error(f"PostgreSQL connection failed during init: {e}")
    except SQLAlchemyError as e:
        logging.error(f"SQLAlchemy error during init: {e}")


async def register_user(update: Update):
    """ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ùˆ ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„ØªÙ‡ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø¨ÙŠØ§Ù†Ø§Øª Postgres."""
    if not engine: return
    user = update.effective_user
    
    init_db() 
    
    insert_query = text("""
        INSERT INTO users (user_id, first_name, username, is_active) 
        VALUES (:user_id, :first_name, :username, 1)
        ON CONFLICT (user_id) DO UPDATE SET 
            first_name = EXCLUDED.first_name,
            username = EXCLUDED.username,
            is_active = 1;
    """)

    try:
        with engine.connect() as connection:
            connection.execute(insert_query, {
                "user_id": user.id,
                "first_name": user.first_name,
                "username": user.username or ''
            })
            connection.commit()
    except SQLAlchemyError as e:
        logging.error(f"Error registering user in Postgres: {e}")


def log_message(user_id, content, msg_type):
    if not engine: return
    
    # Ø¶Ù…Ø§Ù† Ø£Ù† Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ù„Ø§ ÙŠØªØ¬Ø§ÙˆØ² Ø­Ø¬Ù… Ø§Ù„Ø­Ù‚Ù„ ÙÙŠ Ø§Ù„Ù‚Ø§Ø¹Ø¯Ø©
    content_to_log = str(content)[:65535] 
    
    query = text("INSERT INTO messages (user_id, message_content, message_type) VALUES (:user_id, :content, :msg_type)")
    try:
        with engine.connect() as connection:
            connection.execute(query, {"user_id": user_id, "content": content_to_log, "msg_type": msg_type})
            connection.commit()
    except SQLAlchemyError as e:
        logging.error(f"Error logging message: {e}")


def update_user_status(user_id, status):
    """Ø¯Ø§Ù„Ø© Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (0 = ØºÙŠØ± Ù†Ø´Ø·/Ø­Ø¸Ø±ØŒ 1 = Ù†Ø´Ø·) ÙÙŠ Postgres."""
    if not engine: return
    
    update_query = text("UPDATE users SET is_active = :status WHERE user_id = :user_id")
    
    try:
        with engine.connect() as connection:
            connection.execute(update_query, {"status": status, "user_id": user_id})
            connection.commit()
    except SQLAlchemyError as e:
        logging.error(f"Error updating user status in Postgres: {e}")

# ----------------------------------------
# 3. Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
# ----------------------------------------
def split_text(text, max_len=MAX_TELEGRAM_MESSAGE_LENGTH):
    """
    ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ Ø§Ù„Ø·ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø£Ø¬Ø²Ø§Ø¡ Ù„Ø§ ØªØªØ¬Ø§ÙˆØ² Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ (4096 Ø­Ø±ÙØ§Ù‹)ØŒ 
    Ù…Ø¹ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ ÙÙˆØ§ØµÙ„ Ø§Ù„Ø£Ø³Ø·Ø± ÙˆØ§Ù„ÙÙ‚Ø±Ø§Øª.
    """
    if len(text) <= max_len:
        return [text]
    
    parts = []
    current_part = ""
    
    lines = text.splitlines(keepends=True)
    
    for line in lines:
        while len(line) > max_len:
            segment = line[:max_len]
            if current_part:
                parts.append(current_part.strip())
                current_part = "" 
            parts.append(segment.strip())
            line = line[max_len:]

        if len(current_part) + len(line) > max_len:
            if current_part:
                parts.append(current_part.strip())
            current_part = line
        else:
            current_part += line

    if current_part:
        parts.append(current_part.strip())
        
    return [p for p in parts if p]


# ----------------------------------------
# 4. Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Gemini
# ----------------------------------------
BOT_TOKEN = os.getenv("BOT_TOKEN")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
WEBHOOK_URL = os.getenv("WEBHOOK_URL")

client = genai.Client(api_key=GEMINI_API_KEY) if GEMINI_API_KEY else None

FILE_PROCESSING_PROMPT = """
Ø£Ù†Øª Ø¨ÙˆØª Ù…Ø¹Ù„Ù… ÙˆÙ…Ø³Ø§Ø¹Ø¯ Ø¯Ø±Ø§Ø³ÙŠ Ø°ÙƒÙŠ ÙˆÙ…Ø­ØªØ±Ù Ù„Ù„ØºØ§ÙŠØ© ÙˆØ§Ø³Ù…Ùƒ EduVise ğŸŒŸ. Ù…Ù‡Ù…ØªÙƒ ØªØ­Ù„ÙŠÙ„ Ø£ÙŠ Ù…Ø­ØªÙˆÙ‰ ØªØ¹Ù„ÙŠÙ…ÙŠ (ØµÙˆØ±Ø©ØŒ ÙÙŠØ¯ÙŠÙˆØŒ Ù…Ù„Ù PDFØŒ Ø¥Ù„Ø®) ÙˆØªØ­ÙˆÙŠÙ„Ù‡ Ù„Ø­Ø²Ù…Ø© Ø¯Ø±Ø§Ø³ÙŠØ© Ø´Ø§Ù…Ù„Ø© ÙˆÙ…Ø²ÙŠÙ†Ø© Ø¨Ø±Ù…ÙˆØ² Ø¥ÙŠÙ…ÙˆØ¬ÙŠ Ù…Ù†Ø§Ø³Ø¨Ø© Ù„ÙƒÙ„ Ù†Ù‚Ø·Ø© Ù„ØªØ³Ù‡ÙŠÙ„ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© ÙˆØ¬Ø¹Ù„ Ø§Ù„Ù…Ø¸Ù‡Ø± Ø¬Ø°Ø§Ø¨Ø§Ù‹.

**Ù…Ù‡Ù…ØªÙƒ Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©:**
1.  Ø§Ø¨Ø¯Ø£ Ø§Ù„Ø±Ø¯ Ø¨Ù€ **Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø±Ø³** Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ù…Ø­ØªÙˆÙ‰ØŒ Ù…Ø¹ Ø¥ÙŠÙ…ÙˆØ¬ÙŠ Ø¬Ø°Ø§Ø¨.
2.  Ù‚Ø¯Ù… **Ø§Ù„Ø´Ø±Ø­ Ø§Ù„Ù…ÙØµÙ„ ÙˆØ§Ù„Ù…Ù„Ø®Øµ** Ù„Ù„Ù…Ø­ØªÙˆÙ‰ØŒ ÙˆØ§Ø³ØªØ®Ø¯Ù… Ø¥ÙŠÙ…ÙˆØ¬ÙŠ ğŸ“š Ø£Ùˆ ğŸ’¡ Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©.
3.  Ù‚Ø¯Ù… **Ø£Ù…Ø«Ù„Ø© ØªØ·Ø¨ÙŠÙ‚ÙŠØ©**ØŒ ÙˆØ§Ø³ØªØ®Ø¯Ù… Ø¥ÙŠÙ…ÙˆØ¬ÙŠ âœï¸ Ø£Ùˆ ğŸ§ª.
4.  Ù‚Ø¯Ù… **Ù…Ø¬Ù…ÙˆØ¹Ø© Ø£Ø³Ø¦Ù„Ø© Ù…ØªÙ†ÙˆØ¹Ø©** (ØµØ­/Ø®Ø·Ø£ØŒ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† Ù…ØªØ¹Ø¯Ø¯ØŒ Ø£ÙƒÙ…Ù„ØŒ Ø¹Ù„Ù„)ØŒ ÙˆØ§Ø³ØªØ®Ø¯Ù… Ø¥ÙŠÙ…ÙˆØ¬ÙŠ â“ Ø£Ùˆ ğŸ“.
5.  Ù‚Ø¯Ù… **Ø§Ù„Ø£Ø¬ÙˆØ¨Ø© Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ©**ØŒ ÙˆØ§Ø³ØªØ®Ø¯Ù… Ø¥ÙŠÙ…ÙˆØ¬ÙŠ âœ… Ø£Ùˆ ğŸ’¯.

Ù…Ù„Ø§Ø­Ø¸Ø© Ù‡Ø§Ù…Ø©: Ù„Ø§ ØªØ¶Ù Ø£ÙŠ Ù…Ù‚Ø¯Ù…Ø§Øª Ø£Ùˆ Ø´Ø±Ø­ Ù„Ù…Ù‡Ø§Ù…Ùƒ Ø£Ùˆ Ø£ÙŠ Ø¹Ø¨Ø§Ø±Ø§Øª ØªØ´ÙŠØ± Ø¥Ù„Ù‰ ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ø±Ø¯ÙˆØ¯. Ø§Ø¨Ø¯Ø£ Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¯Ø±Ø³ ÙˆØ§Ù„Ø´Ø±Ø­.
"""

def get_or_create_chat(user_id, context: ContextTypes.DEFAULT_TYPE):
    """Ø¬Ù„Ø¨ ÙƒØ§Ø¦Ù† Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø®Ø§Øµ Ø¨Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ùˆ Ø¥Ù†Ø´Ø§Ø¦Ù‡ Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹."""
    if not client:
        return None
        
    chat_key = f'chat_{user_id}'
    
    if chat_key not in context.user_data:
        system_instruction = FILE_PROCESSING_PROMPT.replace('**Ù…Ù‡Ù…ØªÙƒ Ø§Ù„Ù…Ø­Ø¯Ø¯Ø©:**', '')
        system_instruction += "\n\n Ø£Ù†Øª Ø§Ù„Ø¢Ù† ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù†ØµÙˆØµ. Ù…Ù‡Ù…ØªÙƒ Ø§Ù„Ø±Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø³Ø¬Ù„ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚. Ø¥Ø°Ø§ Ø·Ù„Ø¨ ØªØ¹Ø¯ÙŠÙ„ Ø£Ùˆ Ø§Ù„Ø¥Ø´Ø§Ø±Ø© Ø¥Ù„Ù‰ Ø´ÙŠØ¡ Ø³Ø§Ø¨Ù‚ØŒ Ø§ÙÙ‡Ù… Ø§Ù„Ø³ÙŠØ§Ù‚ ÙˆØ¬Ø§ÙˆØ¨Ù‡."
        
        context.user_data[chat_key] = client.chats.create(
            model='gemini-2.5-flash',
            config={'system_instruction': system_instruction} 
        )
    
    return context.user_data[chat_key]

# ----------------------------------------
# 5. Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£ÙˆØ§Ù…Ø± (Handlers)
# ----------------------------------------

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await register_user(update) 
    log_message(update.effective_user.id, "/start", 'command') 
    
    welcome_message = """
Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ğŸ‘‹

Ù‡Ù†Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø±Ø³Ø§Ù„ Ø£ÙŠ Ù…Ù„Ù PDFØŒ ØµÙˆØ±Ø©ØŒ ÙÙŠØ¯ÙŠÙˆØŒ Ù…Ù‚Ø·Ø¹ ØµÙˆØªÙŠ Ø£Ùˆ Ù†ØµØŒ Ù„ÙŠÙ‚ÙˆÙ… Ø§Ù„Ø¨ÙˆØª Ø¨Ù€:

â€¢ ğŸ“„ Ù‚Ø±Ø§Ø¡Ø© ÙˆØªØ­Ù„ÙŠÙ„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø¨Ø¯Ù‚Ø©
â€¢ ğŸ“ Ø´Ø±Ø­ Ø§Ù„Ø¯Ø±ÙˆØ³ ÙˆØ§Ù„Ù…ÙˆØ¶ÙˆØ¹Ø§Øª Ø¨Ø£Ø³Ù„ÙˆØ¨ Ù…Ø¨Ø³Ù‘Ø·
â€¢ ğŸ§ ØªØ­Ù„ÙŠÙ„ ÙˆØ´Ø±Ø­ Ø§Ù„Ù…Ù‚Ø§Ø·Ø¹ Ø§Ù„ØµÙˆØªÙŠØ©
â€¢ ğŸ“š Ø¥Ù†Ø´Ø§Ø¡ Ø£Ù…Ø«Ù„Ø© ØªØ·Ø¨ÙŠÙ‚ÙŠØ©
â€¢ ğŸ§© ØªÙˆÙ„ÙŠØ¯ ØªÙ…Ø§Ø±ÙŠÙ† Ù…Ø®ØµÙ‘ØµØ©
â€¢ â“ Ø·Ø±Ø­ Ø£Ø³Ø¦Ù„Ø© Ù„ÙÙ‡Ù… Ø£Ø¹Ù…Ù‚
â€¢ âœ”ï¸ ØªÙ‚Ø¯ÙŠÙ… Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø§Øª Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠØ©

ÙƒÙ„ Ù…Ø§ Ø¹Ù„ÙŠÙƒ Ù‡Ùˆ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù Ø£Ùˆ Ø§Ù„Ù†Øµ Ø§Ù„Ø¢Ù†â€¦ ÙˆØ³ÙŠØªÙƒÙÙ‘Ù„ Ø§Ù„Ø¨ÙˆØª Ø¨Ø§Ù„Ø¨Ø§Ù‚ÙŠ! ğŸš€ğŸ¤–

ã…¤
ã…¤
Powered by @Albaraa_1
"""
    await update.message.reply_text(welcome_message)

# Ø¨Ø§Ù‚ÙŠ Handlers ÙˆØ¬Ù…ÙŠØ¹ Ø§Ù„Ø£ÙƒÙˆØ§Ø¯ ÙƒÙ…Ø§ Ø£Ø±Ø³Ù„ØªÙ‡Ø§ Ø³Ø§Ø¨Ù‚Ù‹Ø§...

# ----------------------------------------
# 9. Ø§Ù„Ø¯Ù…Ø¬ ÙˆØ§Ù„ØªØ´ØºÙŠÙ„ (Ø§Ù„Ø¥ØµÙ„Ø§Ø­ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ)
# ----------------------------------------

# ğŸ› ï¸ ØªÙ‡ÙŠØ¦Ø© Flask
flask_app = Flask(__name__, static_folder='webapp')
app: Application = None 

# 1. Ù…Ø³Ø§Ø± Ù„Ø®Ø¯Ù…Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…ØµØºØ± (Mini App)
@flask_app.route('/')
def serve_webapp():
    """Ø®Ø¯Ù…Ø© Ù…Ù„Ù index.html Ø¹Ù†Ø¯Ù…Ø§ ÙŠÙØªØ­ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù…ØµØºØ±."""
    return send_from_directory('webapp', 'index.html')

# 2. Ù…Ø³Ø§Ø± Webhook ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù…
@flask_app.route(f"/{BOT_TOKEN}", methods=["POST"])
def telegram_webhook():
    """Ù…Ø¹Ø§Ù„Ø¬ Webhook Ø§Ù„Ø°ÙŠ ÙŠØ³ØªÙ‚Ø¨Ù„ ØªØ­Ø¯ÙŠØ«Ø§Øª ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… ÙˆÙŠØ±Ø³Ù„Ù‡Ø§ Ø¥Ù„Ù‰ Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø¨ÙˆØª."""
    global app
    
    if not app:
        return "Bot Application not initialized", 500
    
    try:
        data = request.get_json(force=True)
        if not data:
            return "No JSON received", 400

        update = Update.de_json(data=data, bot=app.bot)

        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© ÙÙŠ Thread Ù…Ù†ÙØµÙ„
        def run_async_process(update_obj):
            try:
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)
                loop.run_until_complete(app.process_update(update_obj))
            except Exception as e:
                logging.error(f"Error processing update in thread: {e}")

        threading.Thread(target=run_async_process, args=(update,)).start()

        # Ø§Ù„Ø±Ø¯ ÙÙˆØ±Ù‹Ø§ Ø¹Ù„Ù‰ Telegram Ù„ØªØ¬Ù†Ø¨ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ù…Ù‡Ù„Ø©
        return "OK"
        
    except Exception as e:
        logging.error(f"Error in webhook route: {e}")
        return "Error", 500

def main():
    global app
    
    if not BOT_TOKEN or not WEBHOOK_URL:
        print("âŒ Bot Token Ø£Ùˆ Webhook URL Ù…ÙÙ‚ÙˆØ¯! ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦ÙŠØ©.")
        return

    init_db() 
    
    # Ø¥Ø¹Ø¯Ø§Ø¯ ØªØ·Ø¨ÙŠÙ‚ ØªÙŠÙ„ÙŠØ¬Ø±Ø§Ù… (Handlers)
    app = Application.builder().token(BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", start_command))
    app.add_handler(CommandHandler("users", get_users_command)) 
    app.add_handler(CommandHandler("messages_log", get_message_logs))
    app.add_handler(CommandHandler("clean_logs", clean_logs_command))
    app.add_handler(broadcast_handler) 
    app.add_handler(MessageHandler(filters.PHOTO | filters.Document.ALL | filters.VIDEO | filters.AUDIO | filters.VOICE, handle_document))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text)) 

    PORT = int(os.environ.get("PORT", 8443))
    print(f"Bot and WebApp are ready to serve on port {PORT}...")
    
    # Ø¥Ø¹Ø¯Ø§Ø¯ Webhook Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„
    webhook_url_full = f"{WEBHOOK_URL}/{BOT_TOKEN}"
    try:
        app.bot.set_webhook(url=webhook_url_full)
        logging.info(f"âœ… Telegram Webhook set to: {webhook_url_full}")
    except Exception as e:
        logging.error(f"âŒ ÙØ´Ù„ Ø¥Ø¹Ø¯Ø§Ø¯ Telegram Webhook: {e}")

    # ØªØ´ØºÙŠÙ„ Ø®Ø§Ø¯Ù… Flask Ù„Ø®Ø¯Ù…Ø© Ø§Ù„Ù€ Mini App ÙˆØ§Ø³ØªÙ‚Ø¨Ø§Ù„ Webhook
    print(f"ğŸš€ Starting Flask server to handle requests...")
    flask_app.run(host="0.0.0.0", port=PORT)

if __name__ == "__main__":
    main()
